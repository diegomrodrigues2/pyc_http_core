# Implementar fase 3 do backend de rede
_Exported on 7/23/2025 at 16:14:34 GMT-3 from Cursor (1.3.0)_

---

**User**

crie um plano abrangente para implementar a fase 3 usando considerando meu plano high-level @High-Level Plan.md 

e meu código atual.

#### Fase 3: Backend de Rede (Semana 2-3)

4. **Interfaces de Rede** (`network/backend.py`, `network/stream.py`)
   - Interface `NetworkBackend`
   - Interface `NetworkStream`
   - Mocks para testes

5. **Implementação epoll** (`network/epoll.pyx`)
   - Loop de eventos básico
   - `NetworkStream` com epoll
   - Integração Python-Cython

---

**Cursor**

Vou analisar seu código atual e criar um plano detalhado para implementar a Fase 3 do seu projeto. Primeiro, deixe-me examinar a estrutura atual do projeto.


Agora vou criar um plano abrangente para implementar a Fase 3 do seu projeto, considerando o código atual e o plano high-level.

# Plano Detalhado para Fase 3: Backend de Rede

## Visão Geral

A Fase 3 implementa o backend de rede que será a fundação para todas as operações de I/O assíncrono. Esta fase estabelece as interfaces e implementações de baixo nível necessárias para suportar HTTP/1.1, HTTP/2, WebSockets e SSE de forma eficiente.

## Estrutura de Arquivos

```
src/c_http_core/network/
├── __init__.py              # Exports das interfaces principais
├── backend.py               # Interface NetworkBackend
├── stream.py                # Interface NetworkStream
├── epoll.pyx                # Implementação epoll em Cython
├── mock.py                  # Mocks para testes
└── utils.py                 # Utilitários de rede
```

## Etapa 1: Interfaces de Rede (Dia 1-2)

### 1.1 Interface NetworkStream (`network/stream.py`)

**Objetivo:** Definir a interface para streams de rede assíncronas.

```python
# network/stream.py
from abc import ABC, abstractmethod
from typing import Optional, Union
import asyncio

class NetworkStream(ABC):
    """Interface for network streams with async I/O operations."""
    
    @abstractmethod
    async def read(self, max_bytes: Optional[int] = None) -> bytes:
        """Read data from the stream."""
        pass
    
    @abstractmethod
    async def write(self, data: bytes) -> None:
        """Write data to the stream."""
        pass
    
    @abstractmethod
    async def aclose(self) -> None:
        """Close the stream."""
        pass
    
    @abstractmethod
    def get_extra_info(self, name: str) -> Optional[Union[str, int, bool]]:
        """Get extra information about the stream."""
        pass
    
    @property
    @abstractmethod
    def is_closed(self) -> bool:
        """Check if the stream is closed."""
        pass
```

### 1.2 Interface NetworkBackend (`network/backend.py`)

**Objetivo:** Definir a interface para o backend de rede que gerencia conexões.

```python
# network/backend.py
from abc import ABC, abstractmethod
from typing import Optional, Tuple, Union
from .stream import NetworkStream

class NetworkBackend(ABC):
    """Interface for network backend implementations."""
    
    @abstractmethod
    async def connect_tcp(
        self, 
        host: str, 
        port: int, 
        timeout: Optional[float] = None
    ) -> NetworkStream:
        """Connect to a TCP endpoint."""
        pass
    
    @abstractmethod
    async def connect_tls(
        self,
        stream: NetworkStream,
        host: str,
        port: int,
        timeout: Optional[float] = None,
        alpn_protocols: Optional[list[str]] = None,
    ) -> NetworkStream:
        """Upgrade a TCP stream to TLS."""
        pass
    
    @abstractmethod
    async def start_tls(
        self,
        stream: NetworkStream,
        host: str,
        alpn_protocols: Optional[list[str]] = None,
    ) -> NetworkStream:
        """Start TLS on an existing stream (for upgrades)."""
        pass
```

## Etapa 2: Implementação Mock (Dia 2-3)

### 2.1 MockNetworkStream (`network/mock.py`)

**Objetivo:** Implementar mocks para testes unitários.

```python
# network/mock.py
import asyncio
from typing import Optional, Union, Dict, Any
from .stream import NetworkStream
from .backend import NetworkBackend

class MockNetworkStream(NetworkStream):
    """Mock network stream for testing."""
    
    def __init__(self, data: bytes = b""):
        self._data = data
        self._position = 0
        self._closed = False
        self._extra_info: Dict[str, Any] = {}
    
    async def read(self, max_bytes: Optional[int] = None) -> bytes:
        if self._closed:
            raise RuntimeError("Stream is closed")
        
        if self._position >= len(self._data):
            return b""
        
        if max_bytes is None:
            result = self._data[self._position:]
            self._position = len(self._data)
        else:
            end = min(self._position + max_bytes, len(self._data))
            result = self._data[self._position:end]
            self._position = end
        
        return result
    
    async def write(self, data: bytes) -> None:
        if self._closed:
            raise RuntimeError("Stream is closed")
        # In mock, we just append to data
        self._data += data
    
    async def aclose(self) -> None:
        self._closed = True
    
    def get_extra_info(self, name: str) -> Optional[Union[str, int, bool]]:
        return self._extra_info.get(name)
    
    @property
    def is_closed(self) -> bool:
        return self._closed

class MockNetworkBackend(NetworkBackend):
    """Mock network backend for testing."""
    
    def __init__(self):
        self._connections: Dict[Tuple[str, int], MockNetworkStream] = {}
    
    async def connect_tcp(
        self, 
        host: str, 
        port: int, 
        timeout: Optional[float] = None
    ) -> MockNetworkStream:
        key = (host, port)
        if key not in self._connections:
            self._connections[key] = MockNetworkStream()
        return self._connections[key]
    
    async def connect_tls(
        self,
        stream: MockNetworkStream,
        host: str,
        port: int,
        timeout: Optional[float] = None,
        alpn_protocols: Optional[list[str]] = None,
    ) -> MockNetworkStream:
        # Mock TLS connection - just return the same stream
        stream._extra_info["ssl_object"] = True
        stream._extra_info["selected_alpn_protocol"] = "http/1.1"
        return stream
    
    async def start_tls(
        self,
        stream: MockNetworkStream,
        host: str,
        alpn_protocols: Optional[list[str]] = None,
    ) -> MockNetworkStream:
        # Mock TLS upgrade
        stream._extra_info["ssl_object"] = True
        stream._extra_info["selected_alpn_protocol"] = "http/1.1"
        return stream
```

## Etapa 3: Implementação epoll (Dia 4-7)

### 3.1 Estrutura Cython (`network/epoll.pyx`)

**Objetivo:** Implementar o loop de eventos epoll em Cython para máxima performance.

```cython
# network/epoll.pyx
# cython: language_level=3
# distutils: language=c

import asyncio
import socket
import ssl
from typing import Optional, Dict, Set, Callable, Any
from cpython cimport PyObject
from libc.stdlib cimport malloc, free
from libc.string cimport memcpy

cdef extern from "sys/epoll.h":
    cdef int EPOLLIN
    cdef int EPOLLOUT
    cdef int EPOLLERR
    cdef int EPOLLHUP
    cdef int EPOLLET
    cdef int EPOLLONESHOT
    
    cdef int epoll_create(int size)
    cdef int epoll_ctl(int epfd, int op, int fd, void* event)
    cdef int epoll_wait(int epfd, void* events, int maxevents, int timeout)
    
    ctypedef struct epoll_event:
        unsigned int events
        void* data

cdef class EpollEventLoop:
    """High-performance event loop using epoll."""
    
    cdef int epoll_fd
    cdef dict callbacks
    cdef set active_fds
    cdef bint running
    
    def __init__(self):
        self.epoll_fd = epoll_create(1024)
        if self.epoll_fd == -1:
            raise OSError("Failed to create epoll instance")
        
        self.callbacks = {}
        self.active_fds = set()
        self.running = False
    
    def __dealloc__(self):
        if self.epoll_fd != -1:
            import os
            os.close(self.epoll_fd)
    
    def add_reader(self, int fd, callback: Callable):
        """Add a file descriptor for reading."""
        cdef epoll_event event
        event.events = EPOLLIN | EPOLLET
        event.data = <void*>fd
        
        if epoll_ctl(self.epoll_fd, 1, fd, &event) == -1:
            raise OSError(f"Failed to add reader for fd {fd}")
        
        self.callbacks[fd] = callback
        self.active_fds.add(fd)
    
    def add_writer(self, int fd, callback: Callable):
        """Add a file descriptor for writing."""
        cdef epoll_event event
        event.events = EPOLLOUT | EPOLLET
        event.data = <void*>fd
        
        if epoll_ctl(self.epoll_fd, 1, fd, &event) == -1:
            raise OSError(f"Failed to add writer for fd {fd}")
        
        self.callbacks[fd] = callback
        self.active_fds.add(fd)
    
    def remove_reader(self, int fd):
        """Remove a file descriptor from reading."""
        if epoll_ctl(self.epoll_fd, 2, fd, NULL) == -1:
            raise OSError(f"Failed to remove reader for fd {fd}")
        
        self.callbacks.pop(fd, None)
        self.active_fds.discard(fd)
    
    def remove_writer(self, int fd):
        """Remove a file descriptor from writing."""
        if epoll_ctl(self.epoll_fd, 2, fd, NULL) == -1:
            raise OSError(f"Failed to remove writer for fd {fd}")
        
        self.callbacks.pop(fd, None)
        self.active_fds.discard(fd)
    
    async def run_forever(self):
        """Run the event loop."""
        self.running = True
        
        cdef epoll_event events[1024]
        cdef int n_events, i, fd
        
        while self.running:
            n_events = epoll_wait(self.epoll_fd, events, 1024, -1)
            
            if n_events == -1:
                if errno == EINTR:
                    continue
                raise OSError("epoll_wait failed")
            
            for i in range(n_events):
                fd = <int>events[i].data
                if fd in self.callbacks:
                    callback = self.callbacks[fd]
                    try:
                        await callback()
                    except Exception as e:
                        # Handle error
                        pass

cdef class EpollNetworkStream:
    """Network stream implementation using epoll."""
    
    cdef int sock_fd
    cdef EpollEventLoop loop
    cdef bint closed
    cdef bytes buffer
    cdef int buffer_pos
    
    def __init__(self, int sock_fd, EpollEventLoop loop):
        self.sock_fd = sock_fd
        self.loop = loop
        self.closed = False
        self.buffer = b""
        self.buffer_pos = 0
    
    async def read(self, max_bytes: Optional[int] = None) -> bytes:
        if self.closed:
            raise RuntimeError("Stream is closed")
        
        if max_bytes is None:
            max_bytes = 8192  # Default chunk size
        
        cdef bytes data = b""
        cdef int bytes_read
        
        while len(data) < max_bytes:
            bytes_read = socket.recv(self.sock_fd, max_bytes - len(data))
            if bytes_read == 0:
                break
            data += bytes_read
        
        return data
    
    async def write(self, data: bytes) -> None:
        if self.closed:
            raise RuntimeError("Stream is closed")
        
        cdef int total_sent = 0
        cdef int bytes_sent
        
        while total_sent < len(data):
            bytes_sent = socket.send(
                self.sock_fd, 
                data[total_sent:],
                socket.MSG_NOSIGNAL
            )
            if bytes_sent == -1:
                raise OSError("Failed to send data")
            total_sent += bytes_sent
    
    async def aclose(self) -> None:
        if not self.closed:
            socket.close(self.sock_fd)
            self.closed = True
    
    def get_extra_info(self, name: str) -> Optional[Union[str, int, bool]]:
        if name == "socket":
            return self.sock_fd
        elif name == "peername":
            return socket.getpeername(self.sock_fd)
        elif name == "sockname":
            return socket.getsockname(self.sock_fd)
        return None
    
    @property
    def is_closed(self) -> bool:
        return self.closed

cdef class EpollNetworkBackend:
    """Network backend implementation using epoll."""
    
    cdef EpollEventLoop loop
    
    def __init__(self):
        self.loop = EpollEventLoop()
    
    async def connect_tcp(
        self, 
        host: str, 
        port: int, 
        timeout: Optional[float] = None
    ) -> EpollNetworkStream:
        cdef int sock_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Set non-blocking
        socket.setblocking(sock_fd, False)
        
        # Connect
        try:
            socket.connect(sock_fd, (host, port))
        except BlockingIOError:
            # Connection in progress
            pass
        
        # Wait for connection to complete
        if timeout is not None:
            # Implement timeout logic
            pass
        
        return EpollNetworkStream(sock_fd, self.loop)
    
    async def connect_tls(
        self,
        stream: EpollNetworkStream,
        host: str,
        port: int,
        timeout: Optional[float] = None,
        alpn_protocols: Optional[list[str]] = None,
    ) -> EpollNetworkStream:
        # Create SSL context
        context = ssl.create_default_context()
        if alpn_protocols:
            context.set_alpn_protocols(alpn_protocols)
        
        # Wrap socket with SSL
        ssl_sock = context.wrap_socket(
            socket.socket(fileno=stream.sock_fd),
            server_hostname=host
        )
        
        # Create new stream with SSL socket
        return EpollNetworkStream(ssl_sock.fileno(), self.loop)
    
    async def start_tls(
        self,
        stream: EpollNetworkStream,
        host: str,
        alpn_protocols: Optional[list[str]] = None,
    ) -> EpollNetworkStream:
        # Similar to connect_tls but for existing connection
        context = ssl.create_default_context()
        if alpn_protocols:
            context.set_alpn_protocols(alpn_protocols)
        
        ssl_sock = context.wrap_socket(
            socket.socket(fileno=stream.sock_fd),
            server_hostname=host,
            do_handshake_on_connect=False
        )
        
        return EpollNetworkStream(ssl_sock.fileno(), self.loop)
```

### 3.2 Utilitários de Rede (`network/utils.py`)

**Objetivo:** Funções auxiliares para operações de rede.

```python
# network/utils.py
import socket
import ssl
from typing import Optional, Tuple, Union

def create_socket(
    family: int = socket.AF_INET,
    type: int = socket.SOCK_STREAM,
    proto: int = 0
) -> socket.socket:
    """Create a socket with optimal settings."""
    sock = socket.socket(family, type, proto)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    return sock

def create_ssl_context(
    alpn_protocols: Optional[list[str]] = None,
    verify_mode: int = ssl.CERT_REQUIRED,
    check_hostname: bool = True
) -> ssl.SSLContext:
    """Create an SSL context with optimal settings."""
    context = ssl.create_default_context()
    context.verify_mode = verify_mode
    context.check_hostname = check_hostname
    
    if alpn_protocols:
        context.set_alpn_protocols(alpn_protocols)
    
    # Optimize for performance
    context.options |= ssl.OP_NO_COMPRESSION
    context.options |= ssl.OP_NO_RENEGOTIATION
    
    return context

def parse_url(url: str) -> Tuple[str, str, int, str]:
    """Parse URL into components."""
    from urllib.parse import urlparse
    
    parsed = urlparse(url)
    scheme = parsed.scheme or "http"
    host = parsed.hostname or ""
    port = parsed.port or (443 if scheme == "https" else 80)
    path = parsed.path or "/"
    
    return scheme, host, port, path

def format_host_header(host: str, port: int, scheme: str) -> str:
    """Format host header for HTTP requests."""
    if (scheme == "https" and port == 443) or (scheme == "http" and port == 80):
        return host
    return f"{host}:{port}"
```

## Etapa 4: Integração e Testes (Dia 8-10)

### 4.1 Atualização do `__init__.py`

```python
# network/__init__.py
"""
Network backend components for c_http_core.

This module provides the low-level networking abstractions
including the event loop and network streams.
"""

from .backend import NetworkBackend
from .stream import NetworkStream
from .mock import MockNetworkBackend, MockNetworkStream

try:
    from .epoll import EpollNetworkBackend, EpollNetworkStream, EpollEventLoop
    HAS_EPOLL = True
except ImportError:
    HAS_EPOLL = False

__all__ = [
    "NetworkBackend", 
    "NetworkStream",
    "MockNetworkBackend", 
    "MockNetworkStream",
]

if HAS_EPOLL:
    __all__.extend([
        "EpollNetworkBackend", 
        "EpollNetworkStream", 
        "EpollEventLoop"
    ])
```

### 4.2 Testes Unitários

```python
# tests/test_network.py
import pytest
import asyncio
from c_http_core.network import (
    MockNetworkBackend, 
    MockNetworkStream,
    NetworkBackend,
    NetworkStream
)

class TestMockNetworkStream:
    @pytest.mark.asyncio
    async def test_read_write(self):
        stream = MockNetworkStream()
        
        # Test write
        await stream.write(b"hello world")
        
        # Test read
        data = await stream.read(5)
        assert data == b"hello"
        
        data = await stream.read()
        assert data == b" world"
    
    @pytest.mark.asyncio
    async def test_close(self):
        stream = MockNetworkStream()
        assert not stream.is_closed
        
        await stream.aclose()
        assert stream.is_closed
        
        with pytest.raises(RuntimeError):
            await stream.read()

class TestMockNetworkBackend:
    @pytest.mark.asyncio
    async def test_connect_tcp(self):
        backend = MockNetworkBackend()
        stream = await backend.connect_tcp("example.com", 80)
        
        assert isinstance(stream, MockNetworkStream)
        assert not stream.is_closed
    
    @pytest.mark.asyncio
    async def test_connect_tls(self):
        backend = MockNetworkBackend()
        tcp_stream = await backend.connect_tcp("example.com", 443)
        tls_stream = await backend.connect_tls(tcp_stream, "example.com", 443)
        
        assert tls_stream.get_extra_info("ssl_object") is True
        assert tls_stream.get_extra_info("selected_alpn_protocol") == "http/1.1"

class TestEpollNetworkBackend:
    @pytest.mark.skipif(not HAS_EPOLL, reason="epoll not available")
    @pytest.mark.asyncio
    async def test_connect_tcp(self):
        backend = EpollNetworkBackend()
        # Test with a real connection to localhost
        try:
            stream = await backend.connect_tcp("127.0.0.1", 80)
            assert isinstance(stream, EpollNetworkStream)
            await stream.aclose()
        except OSError:
            # Expected if no server on port 80
            pass
```

## Etapa 5: Configuração de Build (Dia 10)

### 5.1 Atualização do `pyproject.toml`

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel", "Cython>=3.0"]
build-backend = "setuptools.build_meta"

[project]
# ... existing config ...
dependencies = [
    "h11>=0.14.0",
    "typing-extensions>=4.0.0",
    "setuptools>=61.0",
]

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools.package-data]
"c_http_core.network" = ["*.pxd"]

[tool.cython]
language_level = 3
```

### 5.2 Setup.py para Cython

```python
# setup.py
from setuptools import setup, Extension
from Cython.Build import cythonize
import numpy

extensions = [
    Extension(
        "c_http_core.network.epoll",
        ["src/c_http_core/network/epoll.pyx"],
        libraries=["c"],
        extra_compile_args=["-O3"],
    )
]

setup(
    ext_modules=cythonize(extensions, compiler_directives={
        'language_level': 3,
        'boundscheck': False,
        'wraparound': False,
        'initializedcheck': False,
    })
)
```

## Cronograma Detalhado

### Semana 1: Interfaces e Mocks
- **Dia 1-2**: Implementar `NetworkStream` e `NetworkBackend` interfaces
- **Dia 3**: Implementar mocks para testes
- **Dia 4**: Testes unitários para interfaces e mocks

### Semana 2: Implementação epoll
- **Dia 5-6**: Implementar `EpollEventLoop` em Cython
- **Dia 7**: Implementar `EpollNetworkStream` e `EpollNetworkBackend`
- **Dia 8**: Utilitários de rede e integração

### Semana 3: Testes e Refinamento
- **Dia 9**: Testes de integração e performance
- **Dia 10**: Configuração de build e documentação

## Critérios de Aceitação

1. **Interfaces Bem Definidas**: `NetworkStream` e `NetworkBackend` devem ser claras e extensíveis
2. **Mocks Funcionais**: Testes unitários devem passar com mocks
3. **Performance epoll**: Implementação Cython deve ser significativamente mais rápida que asyncio padrão
4. **Compatibilidade**: Deve funcionar em Linux (epoll) com fallback para outros sistemas
5. **TLS Support**: Suporte completo a TLS com ALPN
6. **Testes Abrangentes**: Cobertura de testes > 90%

## Próximos Passos

Após a conclusão da Fase 3, você estará pronto para implementar:

1. **Fase 4**: HTTP/1.1 Connection usando as interfaces de rede
2. **Fase 5**: Connection Pool para gerenciar múltiplas conexões
3. **Fase 6**: HTTP/2 Connection com multiplexação

A Fase 3 estabelece a fundação sólida necessária para todas as funcionalidades de rede de alto desempenho do seu projeto.

```plaintext
src/c_http_core/network/
├── __init__.py              # Exports das interfaces principais
├── backend.py               # Interface NetworkBackend
├── stream.py                # Interface NetworkStream
├── epoll.pyx                # Implementação epoll em Cython
├── mock.py                  # Mocks para testes
└── utils.py                 # Utilitários de rede
```

```python
# network/stream.py
from abc import ABC, abstractmethod
from typing import Optional, Union
import asyncio

class NetworkStream(ABC):
    """Interface for network streams with async I/O operations."""
    
    @abstractmethod
    async def read(self, max_bytes: Optional[int] = None) -> bytes:
        """Read data from the stream."""
        pass
    
    @abstractmethod
    async def write(self, data: bytes) -> None:
        """Write data to the stream."""
        pass
    
    @abstractmethod
    async def aclose(self) -> None:
        """Close the stream."""
        pass
    
    @abstractmethod
    def get_extra_info(self, name: str) -> Optional[Union[str, int, bool]]:
        """Get extra information about the stream."""
        pass
    
    @property
    @abstractmethod
    def is_closed(self) -> bool:
        """Check if the stream is closed."""
        pass
```

```python
# network/backend.py
from abc import ABC, abstractmethod
from typing import Optional, Tuple, Union
from .stream import NetworkStream

class NetworkBackend(ABC):
    """Interface for network backend implementations."""
    
    @abstractmethod
    async def connect_tcp(
        self, 
        host: str, 
        port: int, 
        timeout: Optional[float] = None
    ) -> NetworkStream:
        """Connect to a TCP endpoint."""
        pass
    
    @abstractmethod
    async def connect_tls(
        self,
        stream: NetworkStream,
        host: str,
        port: int,
        timeout: Optional[float] = None,
        alpn_protocols: Optional[list[str]] = None,
    ) -> NetworkStream:
        """Upgrade a TCP stream to TLS."""
        pass
    
    @abstractmethod
    async def start_tls(
        self,
        stream: NetworkStream,
        host: str,
        alpn_protocols: Optional[list[str]] = None,
    ) -> NetworkStream:
        """Start TLS on an existing stream (for upgrades)."""
        pass
```

```python
# network/mock.py
import asyncio
from typing import Optional, Union, Dict, Any
from .stream import NetworkStream
from .backend import NetworkBackend

class MockNetworkStream(NetworkStream):
    """Mock network stream for testing."""
    
    def __init__(self, data: bytes = b""):
        self._data = data
        self._position = 0
        self._closed = False
        self._extra_info: Dict[str, Any] = {}
    
    async def read(self, max_bytes: Optional[int] = None) -> bytes:
        if self._closed:
            raise RuntimeError("Stream is closed")
        
        if self._position >= len(self._data):
            return b""
        
        if max_bytes is None:
            result = self._data[self._position:]
            self._position = len(self._data)
        else:
            end = min(self._position + max_bytes, len(self._data))
            result = self._data[self._position:end]
            self._position = end
        
        return result
    
    async def write(self, data: bytes) -> None:
        if self._closed:
            raise RuntimeError("Stream is closed")
        # In mock, we just append to data
        self._data += data
    
    async def aclose(self) -> None:
        self._closed = True
    
    def get_extra_info(self, name: str) -> Optional[Union[str, int, bool]]:
        return self._extra_info.get(name)
    
    @property
    def is_closed(self) -> bool:
        return self._closed

class MockNetworkBackend(NetworkBackend):
    """Mock network backend for testing."""
    
    def __init__(self):
        self._connections: Dict[Tuple[str, int], MockNetworkStream] = {}
    
    async def connect_tcp(
        self, 
        host: str, 
        port: int, 
        timeout: Optional[float] = None
    ) -> MockNetworkStream:
        key = (host, port)
        if key not in self._connections:
            self._connections[key] = MockNetworkStream()
        return self._connections[key]
    
    async def connect_tls(
        self,
        stream: MockNetworkStream,
        host: str,
        port: int,
        timeout: Optional[float] = None,
        alpn_protocols: Optional[list[str]] = None,
    ) -> MockNetworkStream:
        # Mock TLS connection - just return the same stream
        stream._extra_info["ssl_object"] = True
        stream._extra_info["selected_alpn_protocol"] = "http/1.1"
        return stream
    
    async def start_tls(
        self,
        stream: MockNetworkStream,
        host: str,
        alpn_protocols: Optional[list[str]] = None,
    ) -> MockNetworkStream:
        # Mock TLS upgrade
        stream._extra_info["ssl_object"] = True
        stream._extra_info["selected_alpn_protocol"] = "http/1.1"
        return stream
```

```cython
# network/epoll.pyx
# cython: language_level=3
# distutils: language=c

import asyncio
import socket
import ssl
from typing import Optional, Dict, Set, Callable, Any
from cpython cimport PyObject
from libc.stdlib cimport malloc, free
from libc.string cimport memcpy

cdef extern from "sys/epoll.h":
    cdef int EPOLLIN
    cdef int EPOLLOUT
    cdef int EPOLLERR
    cdef int EPOLLHUP
    cdef int EPOLLET
    cdef int EPOLLONESHOT
    
    cdef int epoll_create(int size)
    cdef int epoll_ctl(int epfd, int op, int fd, void* event)
    cdef int epoll_wait(int epfd, void* events, int maxevents, int timeout)
    
    ctypedef struct epoll_event:
        unsigned int events
        void* data

cdef class EpollEventLoop:
    """High-performance event loop using epoll."""
    
    cdef int epoll_fd
    cdef dict callbacks
    cdef set active_fds
    cdef bint running
    
    def __init__(self):
        self.epoll_fd = epoll_create(1024)
        if self.epoll_fd == -1:
            raise OSError("Failed to create epoll instance")
        
        self.callbacks = {}
        self.active_fds = set()
        self.running = False
    
    def __dealloc__(self):
        if self.epoll_fd != -1:
            import os
            os.close(self.epoll_fd)
    
    def add_reader(self, int fd, callback: Callable):
        """Add a file descriptor for reading."""
        cdef epoll_event event
        event.events = EPOLLIN | EPOLLET
        event.data = <void*>fd
        
        if epoll_ctl(self.epoll_fd, 1, fd, &event) == -1:
            raise OSError(f"Failed to add reader for fd {fd}")
        
        self.callbacks[fd] = callback
        self.active_fds.add(fd)
    
    def add_writer(self, int fd, callback: Callable):
        """Add a file descriptor for writing."""
        cdef epoll_event event
        event.events = EPOLLOUT | EPOLLET
        event.data = <void*>fd
        
        if epoll_ctl(self.epoll_fd, 1, fd, &event) == -1:
            raise OSError(f"Failed to add writer for fd {fd}")
        
        self.callbacks[fd] = callback
        self.active_fds.add(fd)
    
    def remove_reader(self, int fd):
        """Remove a file descriptor from reading."""
        if epoll_ctl(self.epoll_fd, 2, fd, NULL) == -1:
            raise OSError(f"Failed to remove reader for fd {fd}")
        
        self.callbacks.pop(fd, None)
        self.active_fds.discard(fd)
    
    def remove_writer(self, int fd):
        """Remove a file descriptor from writing."""
        if epoll_ctl(self.epoll_fd, 2, fd, NULL) == -1:
            raise OSError(f"Failed to remove writer for fd {fd}")
        
        self.callbacks.pop(fd, None)
        self.active_fds.discard(fd)
    
    async def run_forever(self):
        """Run the event loop."""
        self.running = True
        
        cdef epoll_event events[1024]
        cdef int n_events, i, fd
        
        while self.running:
            n_events = epoll_wait(self.epoll_fd, events, 1024, -1)
            
            if n_events == -1:
                if errno == EINTR:
                    continue
                raise OSError("epoll_wait failed")
            
            for i in range(n_events):
                fd = <int>events[i].data
                if fd in self.callbacks:
                    callback = self.callbacks[fd]
                    try:
                        await callback()
                    except Exception as e:
                        # Handle error
                        pass

cdef class EpollNetworkStream:
    """Network stream implementation using epoll."""
    
    cdef int sock_fd
    cdef EpollEventLoop loop
    cdef bint closed
    cdef bytes buffer
    cdef int buffer_pos
    
    def __init__(self, int sock_fd, EpollEventLoop loop):
        self.sock_fd = sock_fd
        self.loop = loop
        self.closed = False
        self.buffer = b""
        self.buffer_pos = 0
    
    async def read(self, max_bytes: Optional[int] = None) -> bytes:
        if self.closed:
            raise RuntimeError("Stream is closed")
        
        if max_bytes is None:
            max_bytes = 8192  # Default chunk size
        
        cdef bytes data = b""
        cdef int bytes_read
        
        while len(data) < max_bytes:
            bytes_read = socket.recv(self.sock_fd, max_bytes - len(data))
            if bytes_read == 0:
                break
            data += bytes_read
        
        return data
    
    async def write(self, data: bytes) -> None:
        if self.closed:
            raise RuntimeError("Stream is closed")
        
        cdef int total_sent = 0
        cdef int bytes_sent
        
        while total_sent < len(data):
            bytes_sent = socket.send(
                self.sock_fd, 
                data[total_sent:],
                socket.MSG_NOSIGNAL
            )
            if bytes_sent == -1:
                raise OSError("Failed to send data")
            total_sent += bytes_sent
    
    async def aclose(self) -> None:
        if not self.closed:
            socket.close(self.sock_fd)
            self.closed = True
    
    def get_extra_info(self, name: str) -> Optional[Union[str, int, bool]]:
        if name == "socket":
            return self.sock_fd
        elif name == "peername":
            return socket.getpeername(self.sock_fd)
        elif name == "sockname":
            return socket.getsockname(self.sock_fd)
        return None
    
    @property
    def is_closed(self) -> bool:
        return self.closed

cdef class EpollNetworkBackend:
    """Network backend implementation using epoll."""
    
    cdef EpollEventLoop loop
    
    def __init__(self):
        self.loop = EpollEventLoop()
    
    async def connect_tcp(
        self, 
        host: str, 
        port: int, 
        timeout: Optional[float] = None
    ) -> EpollNetworkStream:
        cdef int sock_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Set non-blocking
        socket.setblocking(sock_fd, False)
        
        # Connect
        try:
            socket.connect(sock_fd, (host, port))
        except BlockingIOError:
            # Connection in progress
            pass
        
        # Wait for connection to complete
        if timeout is not None:
            # Implement timeout logic
            pass
        
        return EpollNetworkStream(sock_fd, self.loop)
    
    async def connect_tls(
        self,
        stream: EpollNetworkStream,
        host: str,
        port: int,
        timeout: Optional[float] = None,
        alpn_protocols: Optional[list[str]] = None,
    ) -> EpollNetworkStream:
        # Create SSL context
        context = ssl.create_default_context()
        if alpn_protocols:
            context.set_alpn_protocols(alpn_protocols)
        
        # Wrap socket with SSL
        ssl_sock = context.wrap_socket(
            socket.socket(fileno=stream.sock_fd),
            server_hostname=host
        )
        
        # Create new stream with SSL socket
        return EpollNetworkStream(ssl_sock.fileno(), self.loop)
    
    async def start_tls(
        self,
        stream: EpollNetworkStream,
        host: str,
        alpn_protocols: Optional[list[str]] = None,
    ) -> EpollNetworkStream:
        # Similar to connect_tls but for existing connection
        context = ssl.create_default_context()
        if alpn_protocols:
            context.set_alpn_protocols(alpn_protocols)
        
        ssl_sock = context.wrap_socket(
            socket.socket(fileno=stream.sock_fd),
            server_hostname=host,
            do_handshake_on_connect=False
        )
        
        return EpollNetworkStream(ssl_sock.fileno(), self.loop)
```

```python
# network/utils.py
import socket
import ssl
from typing import Optional, Tuple, Union

def create_socket(
    family: int = socket.AF_INET,
    type: int = socket.SOCK_STREAM,
    proto: int = 0
) -> socket.socket:
    """Create a socket with optimal settings."""
    sock = socket.socket(family, type, proto)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    return sock

def create_ssl_context(
    alpn_protocols: Optional[list[str]] = None,
    verify_mode: int = ssl.CERT_REQUIRED,
    check_hostname: bool = True
) -> ssl.SSLContext:
    """Create an SSL context with optimal settings."""
    context = ssl.create_default_context()
    context.verify_mode = verify_mode
    context.check_hostname = check_hostname
    
    if alpn_protocols:
        context.set_alpn_protocols(alpn_protocols)
    
    # Optimize for performance
    context.options |= ssl.OP_NO_COMPRESSION
    context.options |= ssl.OP_NO_RENEGOTIATION
    
    return context

def parse_url(url: str) -> Tuple[str, str, int, str]:
    """Parse URL into components."""
    from urllib.parse import urlparse
    
    parsed = urlparse(url)
    scheme = parsed.scheme or "http"
    host = parsed.hostname or ""
    port = parsed.port or (443 if scheme == "https" else 80)
    path = parsed.path or "/"
    
    return scheme, host, port, path

def format_host_header(host: str, port: int, scheme: str) -> str:
    """Format host header for HTTP requests."""
    if (scheme == "https" and port == 443) or (scheme == "http" and port == 80):
        return host
    return f"{host}:{port}"
```

```python
# network/__init__.py
"""
Network backend components for c_http_core.

This module provides the low-level networking abstractions
including the event loop and network streams.
"""

from .backend import NetworkBackend
from .stream import NetworkStream
from .mock import MockNetworkBackend, MockNetworkStream

try:
    from .epoll import EpollNetworkBackend, EpollNetworkStream, EpollEventLoop
    HAS_EPOLL = True
except ImportError:
    HAS_EPOLL = False

__all__ = [
    "NetworkBackend", 
    "NetworkStream",
    "MockNetworkBackend", 
    "MockNetworkStream",
]

if HAS_EPOLL:
    __all__.extend([
        "EpollNetworkBackend", 
        "EpollNetworkStream", 
        "EpollEventLoop"
    ])
```

```python
# tests/test_network.py
import pytest
import asyncio
from c_http_core.network import (
    MockNetworkBackend, 
    MockNetworkStream,
    NetworkBackend,
    NetworkStream
)

class TestMockNetworkStream:
    @pytest.mark.asyncio
    async def test_read_write(self):
        stream = MockNetworkStream()
        
        # Test write
        await stream.write(b"hello world")
        
        # Test read
        data = await stream.read(5)
        assert data == b"hello"
        
        data = await stream.read()
        assert data == b" world"
    
    @pytest.mark.asyncio
    async def test_close(self):
        stream = MockNetworkStream()
        assert not stream.is_closed
        
        await stream.aclose()
        assert stream.is_closed
        
        with pytest.raises(RuntimeError):
            await stream.read()

class TestMockNetworkBackend:
    @pytest.mark.asyncio
    async def test_connect_tcp(self):
        backend = MockNetworkBackend()
        stream = await backend.connect_tcp("example.com", 80)
        
        assert isinstance(stream, MockNetworkStream)
        assert not stream.is_closed
    
    @pytest.mark.asyncio
    async def test_connect_tls(self):
        backend = MockNetworkBackend()
        tcp_stream = await backend.connect_tcp("example.com", 443)
        tls_stream = await backend.connect_tls(tcp_stream, "example.com", 443)
        
        assert tls_stream.get_extra_info("ssl_object") is True
        assert tls_stream.get_extra_info("selected_alpn_protocol") == "http/1.1"

class TestEpollNetworkBackend:
    @pytest.mark.skipif(not HAS_EPOLL, reason="epoll not available")
    @pytest.mark.asyncio
    async def test_connect_tcp(self):
        backend = EpollNetworkBackend()
        # Test with a real connection to localhost
        try:
            stream = await backend.connect_tcp("127.0.0.1", 80)
            assert isinstance(stream, EpollNetworkStream)
            await stream.aclose()
        except OSError:
            # Expected if no server on port 80
            pass
```

```toml
[build-system]
requires = ["setuptools>=61.0", "wheel", "Cython>=3.0"]
build-backend = "setuptools.build_meta"

[project]
# ... existing config ...
dependencies = [
    "h11>=0.14.0",
    "typing-extensions>=4.0.0",
    "setuptools>=61.0",
]

[tool.setuptools.packages.find]
where = ["src"]

[tool.setuptools.package-data]
"c_http_core.network" = ["*.pxd"]

[tool.cython]
language_level = 3
```

```python
# setup.py
from setuptools import setup, Extension
from Cython.Build import cythonize
import numpy

extensions = [
    Extension(
        "c_http_core.network.epoll",
        ["src/c_http_core/network/epoll.pyx"],
        libraries=["c"],
        extra_compile_args=["-O3"],
    )
]

setup(
    ext_modules=cythonize(extensions, compiler_directives={
        'language_level': 3,
        'boundscheck': False,
        'wraparound': False,
        'initializedcheck': False,
    })
)
```

