# Plano para implementação da etapa 4
_Exported on 7/23/2025 at 17:07:14 GMT-3 from Cursor (1.3.0)_

---

**User**

crie um plano abrangente para implementar a etapa 4 considerando o spec high-level @02. File Structure and First Steps.md @01. Initial Plan.md 

considerando também meu código atual:

#### Fase 4: HTTP/1.1 (Semana 3-4)

6. **Conexão HTTP/1.1** (`http11.py`)
   - Integração com `h11`
   - Estados de conexão
   - Keep-alive
   - Testes completos

---

**Cursor**

Vou analisar o código atual e criar um plano abrangente para implementar a Etapa 4 (HTTP/1.1) baseado na especificação e no estado atual do projeto.


Agora vou criar um plano abrangente para implementar a **Etapa 4: HTTP/1.1** baseado na análise do código atual e nas especificações.

# Plano Abrangente: Implementação da Etapa 4 - HTTP/1.1

## Análise do Estado Atual

Com base na análise do código, vejo que você já tem uma base sólida implementada:

### ✅ **Já Implementado:**
- **Primitivas HTTP** (`http_primitives.py`): Classes `Request` e `Response` imutáveis
- **Framework de Streaming** (`streams.py`): `RequestStream` e `ResponseStream` com backpressure natural
- **Backend de Rede** (`network/`): Interfaces `NetworkBackend` e `NetworkStream`
- **Implementação epoll** (`network/epoll.pyx`): Loop de eventos em Cython
- **Mocks para Testes** (`network/mock.py`): Backend simulado para testes

### ❌ **Faltando para Etapa 4:**
- **`http11.py`**: Classe `HTTP11Connection` com integração `h11`
- **Estados de conexão** e **keep-alive**
- **Testes completos** para HTTP/1.1

---

## Plano Detalhado de Implementação

### **Fase 4.1: Estrutura Base da HTTP11Connection (Dias 1-2)**

#### **1.1 Criar arquivo `src/c_http_core/http11.py`**

```python
"""
HTTP/1.1 connection implementation for c_http_core.

This module implements the HTTP11Connection class that manages
HTTP/1.1 protocol communication over a NetworkStream.
"""

import asyncio
from typing import Optional, Dict, Any
from enum import Enum

import h11

from .http_primitives import Request, Response
from .streams import ResponseStream
from .network.stream import NetworkStream
from .exceptions import (
    HTTPCoreError,
    ConnectionError,
    ProtocolError,
    StreamError,
)
```

#### **1.2 Definir Estados da Conexão**

```python
class ConnectionState(Enum):
    """States of an HTTP/1.1 connection."""
    NEW = "new"           # Connection created, not yet used
    ACTIVE = "active"     # Connection handling a request
    IDLE = "idle"         # Connection available for reuse
    CLOSED = "closed"     # Connection closed, cannot be reused
```

#### **1.3 Estrutura Base da HTTP11Connection**

```python
class HTTP11Connection:
    """
    HTTP/1.1 connection manager.
    
    This class manages a single HTTP/1.1 connection over a NetworkStream,
    handling request/response cycles with proper state management and
    keep-alive support.
    """
    
    def __init__(self, stream: NetworkStream):
        """
        Initialize HTTP/1.1 connection.
        
        Args:
            stream: The NetworkStream to use for communication
        """
        self._stream = stream
        self._h11_connection = h11.Connection(h11.CLIENT)
        self._state = ConnectionState.NEW
        self._state_lock = asyncio.Lock()
        self._idle_since: Optional[float] = None
        
    async def handle_request(self, request: Request) -> Response:
        """
        Handle a complete HTTP request/response cycle.
        
        Args:
            request: The HTTP request to send
            
        Returns:
            The HTTP response received
            
        Raises:
            ConnectionError: If connection is not available
            ProtocolError: If HTTP protocol error occurs
        """
        # Implementation will be added in next phase
        pass
```

### **Fase 4.2: Integração com h11 (Dias 3-4)**

#### **2.1 Implementar Envio de Requisição**

```python
async def _send_request(self, request: Request) -> None:
    """
    Send HTTP request using h11.
    
    Args:
        request: The request to send
    """
    # Create h11 Request event
    h11_request = h11.Request(
        method=request.method,
        target=request.path,
        headers=request.headers
    )
    
    # Send request headers
    await self._send_event(h11_request)
    
    # Send request body if present
    if request.stream:
        async for chunk in request.stream:
            h11_data = h11.Data(data=chunk)
            await self._send_event(h11_data)
    
    # Send end of message
    await self._send_event(h11.EndOfMessage())

async def _send_event(self, event: h11.Event) -> None:
    """
    Send an h11 event to the network stream.
    
    Args:
        event: The h11 event to send
    """
    data = self._h11_connection.send(event)
    if data:
        await self._stream.write(data)
```

#### **2.2 Implementar Recepção de Resposta**

```python
async def _receive_response(self) -> Response:
    """
    Receive HTTP response using h11.
    
    Returns:
        The HTTP response with streaming body
    """
    # Read response headers
    while True:
        event = self._h11_connection.next_event()
        
        if event is h11.NEED_DATA:
            data = await self._stream.read(65536)  # 64KB chunks
            if not data:
                raise ProtocolError("Connection closed unexpectedly")
            self._h11_connection.receive_data(data)
            continue
            
        if isinstance(event, h11.Response):
            # Create response with streaming body
            response_stream = ResponseStream(
                connection=self,
                content_length=self._get_content_length(event.headers),
                chunked=self._is_chunked(event.headers)
            )
            
            return Response.create(
                status_code=event.status_code,
                headers=event.headers,
                stream=response_stream
            )
            
        if isinstance(event, h11.ConnectionClosed):
            raise ProtocolError("Connection closed by server")
```

#### **2.3 Implementar Recepção de Corpo**

```python
async def _receive_body_chunk(self) -> Optional[bytes]:
    """
    Receive a chunk of response body.
    
    Returns:
        Chunk of data or None if end of body
    """
    while True:
        event = self._h11_connection.next_event()
        
        if event is h11.NEED_DATA:
            data = await self._stream.read(65536)
            if not data:
                raise ProtocolError("Connection closed unexpectedly")
            self._h11_connection.receive_data(data)
            continue
            
        if isinstance(event, h11.Data):
            return event.data
            
        if isinstance(event, h11.EndOfMessage):
            return None
            
        if isinstance(event, h11.ConnectionClosed):
            raise ProtocolError("Connection closed by server")
```

### **Fase 4.3: Gerenciamento de Estados e Keep-Alive (Dias 5-6)**

#### **3.1 Implementar Controle de Estado**

```python
async def _acquire_connection(self) -> None:
    """
    Acquire connection for use.
    
    Raises:
        ConnectionError: If connection is not available
    """
    async with self._state_lock:
        if self._state == ConnectionState.CLOSED:
            raise ConnectionError("Connection is closed")
        
        if self._state == ConnectionState.ACTIVE:
            raise ConnectionError("Connection is busy")
        
        self._state = ConnectionState.ACTIVE

async def _release_connection(self) -> None:
    """
    Release connection after use.
    """
    async with self._state_lock:
        if self._state == ConnectionState.ACTIVE:
            # Check if connection can be reused
            if self._can_reuse_connection():
                self._state = ConnectionState.IDLE
                self._idle_since = asyncio.get_event_loop().time()
                self._h11_connection.start_next_cycle()
            else:
                self._state = ConnectionState.CLOSED
                await self._stream.aclose()

def _can_reuse_connection(self) -> bool:
    """
    Check if connection can be reused for keep-alive.
    
    Returns:
        True if connection can be reused
    """
    # Check h11 connection state
    if self._h11_connection.their_state != h11.DONE:
        return False
    
    # Check if server indicated connection close
    if hasattr(self._h11_connection, 'they_closed'):
        return not self._h11_connection.they_closed
    
    return True
```

#### **3.2 Implementar Método Principal**

```python
async def handle_request(self, request: Request) -> Response:
    """
    Handle a complete HTTP request/response cycle.
    
    Args:
        request: The HTTP request to send
        
    Returns:
        The HTTP response received
        
    Raises:
        ConnectionError: If connection is not available
        ProtocolError: If HTTP protocol error occurs
    """
    try:
        # Acquire connection
        await self._acquire_connection()
        
        # Send request
        await self._send_request(request)
        
        # Receive response
        response = await self._receive_response()
        
        return response
        
    except Exception:
        # Mark connection as closed on any error
        async with self._state_lock:
            self._state = ConnectionState.CLOSED
        await self._stream.aclose()
        raise
```

### **Fase 4.4: Integração com ResponseStream (Dias 7-8)**

#### **4.1 Atualizar ResponseStream para usar HTTP11Connection**

```python
# Em streams.py, atualizar ResponseStream.__anext__:

async def __anext__(self) -> bytes:
    """Get next chunk of response body."""
    if self._closed:
        raise StopAsyncIteration
    
    try:
        chunk = await self._connection._receive_body_chunk()
        if chunk is None:
            # End of body reached
            self._closed = True
            await self._connection._response_closed()
            raise StopAsyncIteration
        
        self._bytes_read += len(chunk)
        return chunk
        
    except Exception:
        self._closed = True
        raise
```

#### **4.2 Implementar _response_closed**

```python
async def _response_closed(self) -> None:
    """
    Called when response body is fully consumed.
    """
    await self._release_connection()
```

### **Fase 4.5: Testes Completos (Dias 9-10)**

#### **5.1 Criar `tests/test_http11.py`**

```python
"""
Tests for HTTP/1.1 connection implementation.
"""

import pytest
import asyncio
from unittest.mock import AsyncMock, MagicMock

from c_http_core.http11 import HTTP11Connection, ConnectionState
from c_http_core.http_primitives import Request, Response
from c_http_core.network.mock import MockNetworkStream
from c_http_core.streams import create_request_stream


class TestHTTP11Connection:
    """Test HTTP/1.1 connection functionality."""
    
    @pytest.fixture
    def mock_stream(self):
        """Create a mock network stream."""
        return MockNetworkStream()
    
    @pytest.fixture
    def connection(self, mock_stream):
        """Create an HTTP/1.1 connection."""
        return HTTP11Connection(mock_stream)
    
    @pytest.mark.asyncio
    async def test_connection_initialization(self, connection):
        """Test connection initialization."""
        assert connection._state == ConnectionState.NEW
        assert connection._h11_connection is not None
    
    @pytest.mark.asyncio
    async def test_simple_get_request(self, connection, mock_stream):
        """Test simple GET request."""
        # Setup mock response
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Content-Length: 11\r\n"
            b"\r\n"
            b"Hello World"
        )
        
        # Create request
        request = Request.create(
            method="GET",
            url="http://example.com/",
            headers=[(b"Host", b"example.com")]
        )
        
        # Handle request
        response = await connection.handle_request(request)
        
        # Verify response
        assert response.status_code == 200
        assert response.get_header(b"Content-Length") == b"11"
        
        # Verify request was sent
        assert b"GET / HTTP/1.1" in mock_stream.written_data
        assert b"Host: example.com" in mock_stream.written_data
    
    @pytest.mark.asyncio
    async def test_post_request_with_body(self, connection, mock_stream):
        """Test POST request with body."""
        # Setup mock response
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        # Create request with body
        request_stream = create_request_stream(b"Hello, World!")
        request = Request.create(
            method="POST",
            url="http://example.com/",
            headers=[(b"Host", b"example.com")],
            stream=request_stream
        )
        
        # Handle request
        response = await connection.handle_request(request)
        
        # Verify request body was sent
        assert b"Hello, World!" in mock_stream.written_data
    
    @pytest.mark.asyncio
    async def test_keep_alive_connection(self, connection, mock_stream):
        """Test keep-alive connection reuse."""
        # Setup mock response with keep-alive
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Connection: keep-alive\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        # First request
        request1 = Request.create(
            method="GET",
            url="http://example.com/1",
            headers=[(b"Host", b"example.com")]
        )
        
        response1 = await connection.handle_request(request1)
        assert response1.status_code == 200
        
        # Connection should be IDLE
        assert connection._state == ConnectionState.IDLE
        
        # Second request should work
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        request2 = Request.create(
            method="GET",
            url="http://example.com/2",
            headers=[(b"Host", b"example.com")]
        )
        
        response2 = await connection.handle_request(request2)
        assert response2.status_code == 200
    
    @pytest.mark.asyncio
    async def test_connection_close(self, connection, mock_stream):
        """Test connection close handling."""
        # Setup mock response with connection close
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Connection: close\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        request = Request.create(
            method="GET",
            url="http://example.com/",
            headers=[(b"Host", b"example.com")]
        )
        
        response = await connection.handle_request(request)
        assert response.status_code == 200
        
        # Connection should be closed
        assert connection._state == ConnectionState.CLOSED
        assert mock_stream.closed
```

#### **5.2 Testes de Integração com Servidor Real**

```python
@pytest.mark.skipif(not HAS_EPOLL, reason="epoll not available")
class TestHTTP11Integration:
    """Integration tests with real HTTP server."""
    
    @pytest.mark.asyncio
    async def test_httpbin_get(self):
        """Test GET request to httpbin.org."""
        from c_http_core.network import EpollNetworkBackend
        
        backend = EpollNetworkBackend()
        stream = await backend.connect_tcp("httpbin.org", 80)
        connection = HTTP11Connection(stream)
        
        request = Request.create(
            method="GET",
            url="http://httpbin.org/get",
            headers=[(b"Host", b"httpbin.org")]
        )
        
        response = await connection.handle_request(request)
        assert response.status_code == 200
        
        # Read response body
        body = await response.stream.aread()
        assert b"httpbin.org" in body
        
        await connection.close()
    
    @pytest.mark.asyncio
    async def test_httpbin_post(self):
        """Test POST request to httpbin.org."""
        from c_http_core.network import EpollNetworkBackend
        
        backend = EpollNetworkBackend()
        stream = await backend.connect_tcp("httpbin.org", 80)
        connection = HTTP11Connection(stream)
        
        request_stream = create_request_stream(b'{"test": "data"}')
        request = Request.create(
            method="POST",
            url="http://httpbin.org/post",
            headers=[
                (b"Host", b"httpbin.org"),
                (b"Content-Type", b"application/json")
            ],
            stream=request_stream
        )
        
        response = await connection.handle_request(request)
        assert response.status_code == 200
        
        body = await response.stream.aread()
        assert b"test" in body
        assert b"data" in body
        
        await connection.close()
```

### **Fase 4.6: Otimizações e Refinamentos (Dias 11-12)**

#### **6.1 Adicionar Timeouts**

```python
async def handle_request(
    self, 
    request: Request, 
    timeout: Optional[float] = None
) -> Response:
    """
    Handle request with optional timeout.
    
    Args:
        request: The HTTP request to send
        timeout: Optional timeout in seconds
        
    Returns:
        The HTTP response received
    """
    if timeout:
        return await asyncio.wait_for(
            self._handle_request_internal(request),
            timeout=timeout
        )
    else:
        return await self._handle_request_internal(request)
```

#### **6.2 Adicionar Métricas e Logging**

```python
import logging
import time

logger = logging.getLogger(__name__)

class HTTP11Connection:
    def __init__(self, stream: NetworkStream):
        # ... existing code ...
        self._request_count = 0
        self._bytes_sent = 0
        self._bytes_received = 0
    
    async def _handle_request_internal(self, request: Request) -> Response:
        """Internal request handler with metrics."""
        start_time = time.time()
        self._request_count += 1
        
        try:
            response = await self._handle_request_impl(request)
            duration = time.time() - start_time
            
            logger.debug(
                f"Request {self._request_count}: {request.method} {request.path} "
                f"-> {response.status_code} ({duration:.3f}s)"
            )
            
            return response
            
        except Exception as e:
            duration = time.time() - start_time
            logger.error(
                f"Request {self._request_count} failed: {e} ({duration:.3f}s)"
            )
            raise
```

#### **6.3 Implementar Método de Fechamento**

```python
async def close(self) -> None:
    """
    Close the connection and cleanup resources.
    """
    async with self._state_lock:
        if self._state != ConnectionState.CLOSED:
            self._state = ConnectionState.CLOSED
            await self._stream.aclose()
    
    logger.debug(f"Connection closed after {self._request_count} requests")

@property
def is_closed(self) -> bool:
    """Check if connection is closed."""
    return self._state == ConnectionState.CLOSED

@property
def is_idle(self) -> bool:
    """Check if connection is idle and available for reuse."""
    return self._state == ConnectionState.IDLE

def has_expired(self, timeout: float) -> bool:
    """
    Check if idle connection has expired.
    
    Args:
        timeout: Idle timeout in seconds
        
    Returns:
        True if connection has expired
    """
    if self._state != ConnectionState.IDLE or self._idle_since is None:
        return False
    
    return (asyncio.get_event_loop().time() - self._idle_since) > timeout
```

### **Fase 4.7: Documentação e Exemplos (Dias 13-14)**

#### **7.1 Atualizar `examples/basic_client.py`**

```python
"""
Basic HTTP client example using c_http_core.
"""

import asyncio
from c_http_core.http_primitives import Request
from c_http_core.http11 import HTTP11Connection
from c_http_core.network import EpollNetworkBackend
from c_http_core.streams import create_request_stream


async def main():
    """Demonstrate basic HTTP client usage."""
    
    # Create network backend
    backend = EpollNetworkBackend()
    
    # Connect to server
    stream = await backend.connect_tcp("httpbin.org", 80)
    
    # Create HTTP/1.1 connection
    connection = HTTP11Connection(stream)
    
    try:
        # Simple GET request
        print("Making GET request...")
        request = Request.create(
            method="GET",
            url="http://httpbin.org/get",
            headers=[(b"Host", b"httpbin.org")]
        )
        
        response = await connection.handle_request(request)
        print(f"Response: {response.status_code}")
        
        # Read response body
        body = await response.stream.aread()
        print(f"Body length: {len(body)} bytes")
        
        # POST request with body
        print("\nMaking POST request...")
        request_stream = create_request_stream(b'{"message": "Hello, World!"}')
        request = Request.create(
            method="POST",
            url="http://httpbin.org/post",
            headers=[
                (b"Host", b"httpbin.org"),
                (b"Content-Type", b"application/json")
            ],
            stream=request_stream
        )
        
        response = await connection.handle_request(request)
        print(f"Response: {response.status_code}")
        
        body = await response.stream.aread()
        print(f"Body length: {len(body)} bytes")
        
    finally:
        await connection.close()


if __name__ == "__main__":
    asyncio.run(main())
```

#### **7.2 Criar `examples/streaming_example.py`**

```python
"""
Streaming HTTP example using c_http_core.
"""

import asyncio
from c_http_core.http_primitives import Request
from c_http_core.http11 import HTTP11Connection
from c_http_core.network import EpollNetworkBackend
from c_http_core.streams import create_request_stream


async def file_upload_generator():
    """Simulate uploading a large file in chunks."""
    file_content = b"Large file content " * 1000  # ~18KB
    chunk_size = 4096
    
    for i in range(0, len(file_content), chunk_size):
        chunk = file_content[i:i + chunk_size]
        yield chunk
        await asyncio.sleep(0.01)  # Simulate slow upload


async def main():
    """Demonstrate streaming HTTP operations."""
    
    backend = EpollNetworkBackend()
    stream = await backend.connect_tcp("httpbin.org", 80)
    connection = HTTP11Connection(stream)
    
    try:
        # Streaming upload
        print("Uploading large file...")
        request_stream = create_request_stream(
            file_upload_generator(),
            chunked=True
        )
        
        request = Request.create(
            method="POST",
            url="http://httpbin.org/post",
            headers=[
                (b"Host", b"httpbin.org"),
                (b"Content-Type", b"application/octet-stream")
            ],
            stream=request_stream
        )
        
        response = await connection.handle_request(request)
        print(f"Upload response: {response.status_code}")
        
        # Streaming download
        print("\nDownloading large file...")
        request = Request.create(
            method="GET",
            url="http://httpbin.org/bytes/50000",  # 50KB response
            headers=[(b"Host", b"httpbin.org")]
        )
        
        response = await connection.handle_request(request)
        print(f"Download response: {response.status_code}")
        
        # Process response in chunks
        total_bytes = 0
        async for chunk in response.stream:
            total_bytes += len(chunk)
            print(f"Received chunk: {len(chunk)} bytes (total: {total_bytes})")
        
        print(f"Download complete: {total_bytes} bytes")
        
    finally:
        await connection.close()


if __name__ == "__main__":
    asyncio.run(main())
```

---

## Cronograma de Implementação

### **Semana 1 (Dias 1-7):**
- **Dias 1-2**: Estrutura base da HTTP11Connection
- **Dias 3-4**: Integração com h11 (envio/recepção)
- **Dias 5-6**: Gerenciamento de estados e keep-alive
- **Dia 7**: Integração com ResponseStream

### **Semana 2 (Dias 8-14):**
- **Dias 8-10**: Testes completos (unitários e integração)
- **Dias 11-12**: Otimizações e refinamentos
- **Dias 13-14**: Documentação e exemplos

---

## Critérios de Aceitação

### **Funcionalidade:**
- ✅ Suporte completo a HTTP/1.1 (GET, POST, PUT, DELETE, etc.)
- ✅ Streaming de corpos de requisição e resposta
- ✅ Keep-alive com reutilização de conexões
- ✅ Tratamento correto de `Connection: close`
- ✅ Suporte a `Content-Length` e `Transfer-Encoding: chunked`

### **Performance:**
- ✅ Baixa latência usando epoll
- ✅ Streaming eficiente sem carregar tudo na memória
- ✅ Reutilização de conexões para reduzir overhead

### **Robustez:**
- ✅ Tratamento de erros de rede
- ✅ Timeouts configuráveis
- ✅ Estados de conexão bem definidos
- ✅ Thread-safety com locks apropriados

### **Testabilidade:**
- ✅ Testes unitários abrangentes
- ✅ Testes de integração com servidor real
- ✅ Mocks para testes isolados
- ✅ Cobertura de casos edge

---

## Próximos Passos Após Etapa 4

Com a Etapa 4 completa, você terá uma base sólida para:

1. **Etapa 5**: Pool de Conexões (ConnectionPool)
2. **Etapa 6**: Suporte a TLS/SSL
3. **Etapa 7**: HTTP/2 com multiplexação
4. **Etapa 8**: WebSockets e Server-Sent Events

A implementação da HTTP11Connection será o alicerce para todas essas funcionalidades avançadas, seguindo o princípio de "fazer uma coisa bem feita" antes de evoluir para funcionalidades mais complexas.

```python
"""
HTTP/1.1 connection implementation for c_http_core.

This module implements the HTTP11Connection class that manages
HTTP/1.1 protocol communication over a NetworkStream.
"""

import asyncio
from typing import Optional, Dict, Any
from enum import Enum

import h11

from .http_primitives import Request, Response
from .streams import ResponseStream
from .network.stream import NetworkStream
from .exceptions import (
    HTTPCoreError,
    ConnectionError,
    ProtocolError,
    StreamError,
)
```

```python
class ConnectionState(Enum):
    """States of an HTTP/1.1 connection."""
    NEW = "new"           # Connection created, not yet used
    ACTIVE = "active"     # Connection handling a request
    IDLE = "idle"         # Connection available for reuse
    CLOSED = "closed"     # Connection closed, cannot be reused
```

```python
class HTTP11Connection:
    """
    HTTP/1.1 connection manager.
    
    This class manages a single HTTP/1.1 connection over a NetworkStream,
    handling request/response cycles with proper state management and
    keep-alive support.
    """
    
    def __init__(self, stream: NetworkStream):
        """
        Initialize HTTP/1.1 connection.
        
        Args:
            stream: The NetworkStream to use for communication
        """
        self._stream = stream
        self._h11_connection = h11.Connection(h11.CLIENT)
        self._state = ConnectionState.NEW
        self._state_lock = asyncio.Lock()
        self._idle_since: Optional[float] = None
        
    async def handle_request(self, request: Request) -> Response:
        """
        Handle a complete HTTP request/response cycle.
        
        Args:
            request: The HTTP request to send
            
        Returns:
            The HTTP response received
            
        Raises:
            ConnectionError: If connection is not available
            ProtocolError: If HTTP protocol error occurs
        """
        # Implementation will be added in next phase
        pass
```

```python
async def _send_request(self, request: Request) -> None:
    """
    Send HTTP request using h11.
    
    Args:
        request: The request to send
    """
    # Create h11 Request event
    h11_request = h11.Request(
        method=request.method,
        target=request.path,
        headers=request.headers
    )
    
    # Send request headers
    await self._send_event(h11_request)
    
    # Send request body if present
    if request.stream:
        async for chunk in request.stream:
            h11_data = h11.Data(data=chunk)
            await self._send_event(h11_data)
    
    # Send end of message
    await self._send_event(h11.EndOfMessage())

async def _send_event(self, event: h11.Event) -> None:
    """
    Send an h11 event to the network stream.
    
    Args:
        event: The h11 event to send
    """
    data = self._h11_connection.send(event)
    if data:
        await self._stream.write(data)
```

```python
async def _receive_response(self) -> Response:
    """
    Receive HTTP response using h11.
    
    Returns:
        The HTTP response with streaming body
    """
    # Read response headers
    while True:
        event = self._h11_connection.next_event()
        
        if event is h11.NEED_DATA:
            data = await self._stream.read(65536)  # 64KB chunks
            if not data:
                raise ProtocolError("Connection closed unexpectedly")
            self._h11_connection.receive_data(data)
            continue
            
        if isinstance(event, h11.Response):
            # Create response with streaming body
            response_stream = ResponseStream(
                connection=self,
                content_length=self._get_content_length(event.headers),
                chunked=self._is_chunked(event.headers)
            )
            
            return Response.create(
                status_code=event.status_code,
                headers=event.headers,
                stream=response_stream
            )
            
        if isinstance(event, h11.ConnectionClosed):
            raise ProtocolError("Connection closed by server")
```

```python
async def _receive_body_chunk(self) -> Optional[bytes]:
    """
    Receive a chunk of response body.
    
    Returns:
        Chunk of data or None if end of body
    """
    while True:
        event = self._h11_connection.next_event()
        
        if event is h11.NEED_DATA:
            data = await self._stream.read(65536)
            if not data:
                raise ProtocolError("Connection closed unexpectedly")
            self._h11_connection.receive_data(data)
            continue
            
        if isinstance(event, h11.Data):
            return event.data
            
        if isinstance(event, h11.EndOfMessage):
            return None
            
        if isinstance(event, h11.ConnectionClosed):
            raise ProtocolError("Connection closed by server")
```

```python
async def _acquire_connection(self) -> None:
    """
    Acquire connection for use.
    
    Raises:
        ConnectionError: If connection is not available
    """
    async with self._state_lock:
        if self._state == ConnectionState.CLOSED:
            raise ConnectionError("Connection is closed")
        
        if self._state == ConnectionState.ACTIVE:
            raise ConnectionError("Connection is busy")
        
        self._state = ConnectionState.ACTIVE

async def _release_connection(self) -> None:
    """
    Release connection after use.
    """
    async with self._state_lock:
        if self._state == ConnectionState.ACTIVE:
            # Check if connection can be reused
            if self._can_reuse_connection():
                self._state = ConnectionState.IDLE
                self._idle_since = asyncio.get_event_loop().time()
                self._h11_connection.start_next_cycle()
            else:
                self._state = ConnectionState.CLOSED
                await self._stream.aclose()

def _can_reuse_connection(self) -> bool:
    """
    Check if connection can be reused for keep-alive.
    
    Returns:
        True if connection can be reused
    """
    # Check h11 connection state
    if self._h11_connection.their_state != h11.DONE:
        return False
    
    # Check if server indicated connection close
    if hasattr(self._h11_connection, 'they_closed'):
        return not self._h11_connection.they_closed
    
    return True
```

```python
async def handle_request(self, request: Request) -> Response:
    """
    Handle a complete HTTP request/response cycle.
    
    Args:
        request: The HTTP request to send
        
    Returns:
        The HTTP response received
        
    Raises:
        ConnectionError: If connection is not available
        ProtocolError: If HTTP protocol error occurs
    """
    try:
        # Acquire connection
        await self._acquire_connection()
        
        # Send request
        await self._send_request(request)
        
        # Receive response
        response = await self._receive_response()
        
        return response
        
    except Exception:
        # Mark connection as closed on any error
        async with self._state_lock:
            self._state = ConnectionState.CLOSED
        await self._stream.aclose()
        raise
```

```python
# Em streams.py, atualizar ResponseStream.__anext__:

async def __anext__(self) -> bytes:
    """Get next chunk of response body."""
    if self._closed:
        raise StopAsyncIteration
    
    try:
        chunk = await self._connection._receive_body_chunk()
        if chunk is None:
            # End of body reached
            self._closed = True
            await self._connection._response_closed()
            raise StopAsyncIteration
        
        self._bytes_read += len(chunk)
        return chunk
        
    except Exception:
        self._closed = True
        raise
```

```python
async def _response_closed(self) -> None:
    """
    Called when response body is fully consumed.
    """
    await self._release_connection()
```

```python
"""
Tests for HTTP/1.1 connection implementation.
"""

import pytest
import asyncio
from unittest.mock import AsyncMock, MagicMock

from c_http_core.http11 import HTTP11Connection, ConnectionState
from c_http_core.http_primitives import Request, Response
from c_http_core.network.mock import MockNetworkStream
from c_http_core.streams import create_request_stream


class TestHTTP11Connection:
    """Test HTTP/1.1 connection functionality."""
    
    @pytest.fixture
    def mock_stream(self):
        """Create a mock network stream."""
        return MockNetworkStream()
    
    @pytest.fixture
    def connection(self, mock_stream):
        """Create an HTTP/1.1 connection."""
        return HTTP11Connection(mock_stream)
    
    @pytest.mark.asyncio
    async def test_connection_initialization(self, connection):
        """Test connection initialization."""
        assert connection._state == ConnectionState.NEW
        assert connection._h11_connection is not None
    
    @pytest.mark.asyncio
    async def test_simple_get_request(self, connection, mock_stream):
        """Test simple GET request."""
        # Setup mock response
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Content-Length: 11\r\n"
            b"\r\n"
            b"Hello World"
        )
        
        # Create request
        request = Request.create(
            method="GET",
            url="http://example.com/",
            headers=[(b"Host", b"example.com")]
        )
        
        # Handle request
        response = await connection.handle_request(request)
        
        # Verify response
        assert response.status_code == 200
        assert response.get_header(b"Content-Length") == b"11"
        
        # Verify request was sent
        assert b"GET / HTTP/1.1" in mock_stream.written_data
        assert b"Host: example.com" in mock_stream.written_data
    
    @pytest.mark.asyncio
    async def test_post_request_with_body(self, connection, mock_stream):
        """Test POST request with body."""
        # Setup mock response
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        # Create request with body
        request_stream = create_request_stream(b"Hello, World!")
        request = Request.create(
            method="POST",
            url="http://example.com/",
            headers=[(b"Host", b"example.com")],
            stream=request_stream
        )
        
        # Handle request
        response = await connection.handle_request(request)
        
        # Verify request body was sent
        assert b"Hello, World!" in mock_stream.written_data
    
    @pytest.mark.asyncio
    async def test_keep_alive_connection(self, connection, mock_stream):
        """Test keep-alive connection reuse."""
        # Setup mock response with keep-alive
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Connection: keep-alive\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        # First request
        request1 = Request.create(
            method="GET",
            url="http://example.com/1",
            headers=[(b"Host", b"example.com")]
        )
        
        response1 = await connection.handle_request(request1)
        assert response1.status_code == 200
        
        # Connection should be IDLE
        assert connection._state == ConnectionState.IDLE
        
        # Second request should work
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        request2 = Request.create(
            method="GET",
            url="http://example.com/2",
            headers=[(b"Host", b"example.com")]
        )
        
        response2 = await connection.handle_request(request2)
        assert response2.status_code == 200
    
    @pytest.mark.asyncio
    async def test_connection_close(self, connection, mock_stream):
        """Test connection close handling."""
        # Setup mock response with connection close
        mock_stream.read_data = (
            b"HTTP/1.1 200 OK\r\n"
            b"Connection: close\r\n"
            b"Content-Length: 0\r\n"
            b"\r\n"
        )
        
        request = Request.create(
            method="GET",
            url="http://example.com/",
            headers=[(b"Host", b"example.com")]
        )
        
        response = await connection.handle_request(request)
        assert response.status_code == 200
        
        # Connection should be closed
        assert connection._state == ConnectionState.CLOSED
        assert mock_stream.closed
```

```python
@pytest.mark.skipif(not HAS_EPOLL, reason="epoll not available")
class TestHTTP11Integration:
    """Integration tests with real HTTP server."""
    
    @pytest.mark.asyncio
    async def test_httpbin_get(self):
        """Test GET request to httpbin.org."""
        from c_http_core.network import EpollNetworkBackend
        
        backend = EpollNetworkBackend()
        stream = await backend.connect_tcp("httpbin.org", 80)
        connection = HTTP11Connection(stream)
        
        request = Request.create(
            method="GET",
            url="http://httpbin.org/get",
            headers=[(b"Host", b"httpbin.org")]
        )
        
        response = await connection.handle_request(request)
        assert response.status_code == 200
        
        # Read response body
        body = await response.stream.aread()
        assert b"httpbin.org" in body
        
        await connection.close()
    
    @pytest.mark.asyncio
    async def test_httpbin_post(self):
        """Test POST request to httpbin.org."""
        from c_http_core.network import EpollNetworkBackend
        
        backend = EpollNetworkBackend()
        stream = await backend.connect_tcp("httpbin.org", 80)
        connection = HTTP11Connection(stream)
        
        request_stream = create_request_stream(b'{"test": "data"}')
        request = Request.create(
            method="POST",
            url="http://httpbin.org/post",
            headers=[
                (b"Host", b"httpbin.org"),
                (b"Content-Type", b"application/json")
            ],
            stream=request_stream
        )
        
        response = await connection.handle_request(request)
        assert response.status_code == 200
        
        body = await response.stream.aread()
        assert b"test" in body
        assert b"data" in body
        
        await connection.close()
```

```python
async def handle_request(
    self, 
    request: Request, 
    timeout: Optional[float] = None
) -> Response:
    """
    Handle request with optional timeout.
    
    Args:
        request: The HTTP request to send
        timeout: Optional timeout in seconds
        
    Returns:
        The HTTP response received
    """
    if timeout:
        return await asyncio.wait_for(
            self._handle_request_internal(request),
            timeout=timeout
        )
    else:
        return await self._handle_request_internal(request)
```

```python
import logging
import time

logger = logging.getLogger(__name__)

class HTTP11Connection:
    def __init__(self, stream: NetworkStream):
        # ... existing code ...
        self._request_count = 0
        self._bytes_sent = 0
        self._bytes_received = 0
    
    async def _handle_request_internal(self, request: Request) -> Response:
        """Internal request handler with metrics."""
        start_time = time.time()
        self._request_count += 1
        
        try:
            response = await self._handle_request_impl(request)
            duration = time.time() - start_time
            
            logger.debug(
                f"Request {self._request_count}: {request.method} {request.path} "
                f"-> {response.status_code} ({duration:.3f}s)"
            )
            
            return response
            
        except Exception as e:
            duration = time.time() - start_time
            logger.error(
                f"Request {self._request_count} failed: {e} ({duration:.3f}s)"
            )
            raise
```

```python
async def close(self) -> None:
    """
    Close the connection and cleanup resources.
    """
    async with self._state_lock:
        if self._state != ConnectionState.CLOSED:
            self._state = ConnectionState.CLOSED
            await self._stream.aclose()
    
    logger.debug(f"Connection closed after {self._request_count} requests")

@property
def is_closed(self) -> bool:
    """Check if connection is closed."""
    return self._state == ConnectionState.CLOSED

@property
def is_idle(self) -> bool:
    """Check if connection is idle and available for reuse."""
    return self._state == ConnectionState.IDLE

def has_expired(self, timeout: float) -> bool:
    """
    Check if idle connection has expired.
    
    Args:
        timeout: Idle timeout in seconds
        
    Returns:
        True if connection has expired
    """
    if self._state != ConnectionState.IDLE or self._idle_since is None:
        return False
    
    return (asyncio.get_event_loop().time() - self._idle_since) > timeout
```

```python
"""
Basic HTTP client example using c_http_core.
"""

import asyncio
from c_http_core.http_primitives import Request
from c_http_core.http11 import HTTP11Connection
from c_http_core.network import EpollNetworkBackend
from c_http_core.streams import create_request_stream


async def main():
    """Demonstrate basic HTTP client usage."""
    
    # Create network backend
    backend = EpollNetworkBackend()
    
    # Connect to server
    stream = await backend.connect_tcp("httpbin.org", 80)
    
    # Create HTTP/1.1 connection
    connection = HTTP11Connection(stream)
    
    try:
        # Simple GET request
        print("Making GET request...")
        request = Request.create(
            method="GET",
            url="http://httpbin.org/get",
            headers=[(b"Host", b"httpbin.org")]
        )
        
        response = await connection.handle_request(request)
        print(f"Response: {response.status_code}")
        
        # Read response body
        body = await response.stream.aread()
        print(f"Body length: {len(body)} bytes")
        
        # POST request with body
        print("\nMaking POST request...")
        request_stream = create_request_stream(b'{"message": "Hello, World!"}')
        request = Request.create(
            method="POST",
            url="http://httpbin.org/post",
            headers=[
                (b"Host", b"httpbin.org"),
                (b"Content-Type", b"application/json")
            ],
            stream=request_stream
        )
        
        response = await connection.handle_request(request)
        print(f"Response: {response.status_code}")
        
        body = await response.stream.aread()
        print(f"Body length: {len(body)} bytes")
        
    finally:
        await connection.close()


if __name__ == "__main__":
    asyncio.run(main())
```

```python
"""
Streaming HTTP example using c_http_core.
"""

import asyncio
from c_http_core.http_primitives import Request
from c_http_core.http11 import HTTP11Connection
from c_http_core.network import EpollNetworkBackend
from c_http_core.streams import create_request_stream


async def file_upload_generator():
    """Simulate uploading a large file in chunks."""
    file_content = b"Large file content " * 1000  # ~18KB
    chunk_size = 4096
    
    for i in range(0, len(file_content), chunk_size):
        chunk = file_content[i:i + chunk_size]
        yield chunk
        await asyncio.sleep(0.01)  # Simulate slow upload


async def main():
    """Demonstrate streaming HTTP operations."""
    
    backend = EpollNetworkBackend()
    stream = await backend.connect_tcp("httpbin.org", 80)
    connection = HTTP11Connection(stream)
    
    try:
        # Streaming upload
        print("Uploading large file...")
        request_stream = create_request_stream(
            file_upload_generator(),
            chunked=True
        )
        
        request = Request.create(
            method="POST",
            url="http://httpbin.org/post",
            headers=[
                (b"Host", b"httpbin.org"),
                (b"Content-Type", b"application/octet-stream")
            ],
            stream=request_stream
        )
        
        response = await connection.handle_request(request)
        print(f"Upload response: {response.status_code}")
        
        # Streaming download
        print("\nDownloading large file...")
        request = Request.create(
            method="GET",
            url="http://httpbin.org/bytes/50000",  # 50KB response
            headers=[(b"Host", b"httpbin.org")]
        )
        
        response = await connection.handle_request(request)
        print(f"Download response: {response.status_code}")
        
        # Process response in chunks
        total_bytes = 0
        async for chunk in response.stream:
            total_bytes += len(chunk)
            print(f"Received chunk: {len(chunk)} bytes (total: {total_bytes})")
        
        print(f"Download complete: {total_bytes} bytes")
        
    finally:
        await connection.close()


if __name__ == "__main__":
    asyncio.run(main())
```

